"""
    Team 23 python handler for user commands.
    Takes input commands from the user & converts them to SQL commands.
    Pings the CS server with commands & expects results.
"""
import psycopg2
from sshtunnel import SSHTunnelForwarder
import argparse
from datetime import datetime, timedelta
import numpy as np

user:str = None
userid:int = None
server:SSHTunnelForwarder = None
cursor = None
connection = None

# takes cur, conn, username.
# if user not found, returns none.
# if found, returns the username.
def login(conn, cur, username):
    global user
    global userid
    cur.execute(f"""
        SELECT username, user_id from p320_23.user where username = '{username}';
    """)
    feedback = cur.fetchone()
    if feedback == None:
        print("No user was found with that name.")
        return
    print("User found. Logged in.")
    user = feedback[0]
    userid = feedback[1]

    # updates the user's last-access by updating their last_access_time to datetime.now().
    now = datetime.now()
    cur.execute(f""" 
        update p320_23.user
        set last_access_time = '{now}'
        where user_id = {userid};
    """)
    conn.commit()

    return feedback

# Requires many arguments.
# in order: username, email, password, first_name, last_name, creation_date, and last_accessed_date.
# creation and last_accessed_date can be generated in the method.
def create_account(conn, cur, username, email, password, f_n, l_n):
    cur.execute(f"""
        select * from p320_23.user where username = '{username}'
                """)
    if cur.fetchone() != None:
        print(f"User {username} already exists.")
        return
    now = datetime.now()
    cur.execute(f"""
        insert into p320_23.user(username, email, password, first_name, last_name, creation_date, last_access_time) values
                                ('{username}', '{email}', '{password}', '{f_n}', '{l_n}', '{now}', '{now}')
                """)
    conn.commit()
    login(cur, conn, username)

# signs you out :)
def logout(conn, cur):
    global user
    global userid
    user = None
    userid = None

# Games MUST be a list of game ids.
def create_collection(conn, cur, name, games):
    print(user, userid)
    cur.execute(f"""
        select * from p320_23.collection where name = '{name}' and
        user_id = {userid};
    """)
    if cur.fetchone() != None:
        print(f"Collection named {name} already exists for this user.")
        return
    cur.execute(f"""
        insert into p320_23.collection(name, user_id) values ('{name}',
        {userid});
    """)
    conn.commit()

    # grabs the autogenerated id from this collection.
    cur.execute(f"""
        select collection_id from p320_23.collection where name = '{name}' and user_id = {userid};
    """)
    coll_id = cur.fetchone()[0]
    print(f"Collection {name} created for {user} with new id {coll_id}.")
    # adds each game, one by one, to the game_in_collection list.
    for i in games:
        update_collection(conn, cur, True, coll_id, i)
    # returns the collection id
    return coll_id

# gets all collections belonging to the current user.
# todo: add playtime once implementing play sessions.
def get_all_collections(conn, cur):
    cur.execute(f"""
        select name, collection_id from p320_23.collection where user_id = {userid}; 
    """)
    print("Successfully gathered collections.")
    arr = []
    game_ids = []
    for i in cur.fetchall():
        arr.append([i[0], i[1]])
        # this function also requires all of the games in the list, by name
        cur.execute(f"""
            select count(game_id) from p320_23.game_in_collection where collection_id = {i[1]};
        """)
        arr[-1].append(cur.fetchone()[0])
    for i in range(0, len(arr)):
        cur.execute(f"""
            select sum(end_time - start_time) from p320_23.playtime where user_id = {userid} and game_id in
            (select game_id from p320_23.game_in_collection where collection_id = {arr[i][1]});
        """)
        elapsed_time = np.sum(cur.fetchall())
        print(elapsed_time)
        hours, remainder = divmod(elapsed_time.total_seconds(), 3600)
        minutes = remainder // 60
        for i in range(0, len(arr)):
            arr[i].pop(1)
        arr[i].append(str(int(hours)) + ":" + str(int(minutes)))
    # arr should have n elements each with 4 values (todo: 3 currently).
    # in order, for each element, (name, collection_id, game_count, total_playtime)
    return arr

# deletes all dependencies of this collection, then the collection itself.
def delete_collection(conn, cur, collection_name):
    cur.execute(f"""
        select * from p320_23.collection where user_id = {userid} and name = '{collection_name}';
    """)
    if cur.fetchone() == None:
        print("Collection does not exist. No changes were made.")
        return
    # start by deleting the game_in_collection entries with this id
    cur.execute(f"""
        delete from p320_23.game_in_collection where collection_id = (select collection_id from p320_23.collection where user_id = {userid} and name = '{collection_name}');
    """)
    cur.execute(f"""
        delete from p320_23.collection where user_id = {userid} and name = '{collection_name}';
    """)
    conn.commit()
    print(f"Succesfully deleted collection {collection_name}.")

def find_game(connection, cursor, args): # boy thats a lot of args
    ...

# isAdd - if True, adds a new game. If False, do not... do that. Remove it.
def update_collection(conn, cur, isAdd, cid, game):
    if isAdd:
        cur.execute(f"""
            select game_id from p320_23.game_in_collection where collection_id = {cid} and game_id = {game};
        """)
        if cur.fetchone() != None:
            print(f"Game with ID {game} already exists in collection with ID {cid}.")
            return
        cur.execute(f"""
            insert into p320_23.game_in_collection (game_id, collection_id) values ({game}, {cid});
        """)
        conn.commit()
        print(f"Game with id {game} successfully inserted into collection with id {cid}")
    else:
        cur.execute(f"""
            select * from p320_23.game_in_collection where collection_id = {cid} and game_id = {game};
        """)
        if cur.fetchone() == None:
            print(f"Game with id {game} does not exist in collection with ID {cid}.")
        else:
            cur.execute(f"""
                delete from p320_23.game_in_collection where collection_id = {cid} and game_id = {game};
            """)
            conn.commit()
            print(f"Successfully removed game {game} from collection {cid}.")

# if a collection exists, rename it.
# otherwise, reject.
def update_collection_name(conn, cur, oldName, newName):
    cur.execute(f"""
        select * from p320_23.collection where name = '{oldName}' and user_id = {userid};
    """)
    if cur.fetchone() == None:
        print("No collection was found with that name.")
        return
    cur.execute(f"""
        select * from p320_23.collection where name = '{newName}' and user_id = {userid};
    """)
    if cur.fetchone() != None:
        print(f"Collection with new name {newName} already exists.")
        return
    cur.execute(f"""
        update p320_23.collection set name = '{newName}';
    """)
    conn.commit()
    print(f"Sucessfully renamed collection {oldName} into {newName}")

# takes the userid, finds the gameid, and posts a rating (if rating in 1, 2, 3, 4, 5).
# updates ratings where they already exist.
def rate(conn, cur, gamename, rating):
    if not(rating in [1, 2, 3, 4, 5]):
        print("Invalid rating value.")
        return
    cur.execute(f"""
        select game_id from p320_23.game where title = '{gamename}';
    """)
    g_id = cur.fetchone()[0]
    if g_id == None:
        print("Game not found.")
        return
    cur.execute(f"""
        select * from p320_23.rating where user_id = {userid} and game_id = {g_id};
    """)
    if cur.fetchone() != None:
        cur.execute(f"""
            update p320_23.rating set rating = {rating} where game_id = {g_id} and user_id = {userid};
        """)
        conn.commit()
        print("Updated rating.")
    else:
        cur.execute(f"""
            insert into p320_23.rating(user_id, game_id, rating) values ({userid}, {g_id}, {rating});
        """)
        conn.commit()
        print("New rating created.")

# start and end are datetime objects
# game is assumedly a name
def play(conn, cur, game, start, end):
    cur.execute(f"""
        select game_id from p320_23.game where title = '{game}'
    """)
    g_id = cur.fetchone()[0]
    if g_id == None:
        print("Game not found.")
        return
    
    # adds a playsession to the list.
    cur.execute(f"""
        insert into p320_23.playtime(user_id, game_id, start_time, end_time)
        values ({userid}, {g_id}, '{start}', '{end}');
    """)
    conn.commit()
    print("Logged playtime.")

# calls play with end being now, and the beginning being time minutes away.
def play_with_duration(conn, cur, game, time):
    play(conn, cur, game, datetime.now() - timedelta(minutes = time), datetime.now())

# Takes a follower (the logged in user) and a followee.
# creates a connection if none exists.
# prints to console if it was successful or not.
def follow(conn, cur, followee):
    cur.execute(f"""
        SELECT * from following where
        follower_id = {userid}) and 
        following_id = (select user_id from p320_23.user where username = '{followee}');
    """)
    if cur.fetchone() != None:
        print(f"You are already following {followee}.")
        return;
    cur.execute(f"""
        INSERT INTO following(follower_id, following_id) VALUES 
            ({userid}), 
            (SELECT user_id FROM p320_23.user WHERE username='{followee}'));
    """)
    conn.commit()
    print(f"Successfully followed {followee}")

# gets users by a partial email. It can contain the partial email anywhere in the email string.
def get_users_by_email(conn, cur, p_email):
    cur.execute(f"""
        select username, email from p320_23.user where email like '%{p_email}%'; 
    """)
    print("Successfully gathered users.")
    return cur.fetchall()

# Takes a follower (the logged in user) and a followee.
# deletes a connection if it exists.
# prints to console outcome - successful or not.
def unfollow(conn, cur, followee):
    cur.execute(f"""
        select * from p320_23.following where
        follower_id = ({userid}') and 
        following_id = (select user_id from p320_23.user where username = '{followee}');
    """)
    if cur.fetchone() == None:
        print(f"No changes were made. You were not already following {followee}.")
        return
    cur.execute(f""" 
        delete from p320_23.following where 
        follower_id = ({userid}') and
        following_id = (select user_id from p320_23.user where username = '{followee}');
    """)
    conn.commit()
    print(f"Successfully unfollowed {followee}")


def checkCommandsList(connection, cursor, username, command):
    """
    help
        - lists user commands.
    login <USERNAME>
        - logs in to account. enables all commands below this line.
    logout
        - logs out of user account.
    create collection <NAME> (game1, game2, game3...)
        - creates a collection linked to the user with name NAME and contents gamei.
    view collection
        - prints the list of collections associated with the user, ascending order. returns collection name, # of games, and total playtime.
    find game <(n)ame|(p)latform|(r)elease date|(d)eveloper|(pu)blisher|(pl)aytime|(ra)tings> <VALUE> sort by <(n)ame|(p)rice|(g)enre|(r)elease year> <(a)scending|(d)escending>
        - finds a game by VALUE (specified by type) and sorts by field (asc / desc). Sorted ascending by name then release date by default.
    update collection <(a)dd|(r)emove> <NAME1> <NAME2>
        - adds / removes game with name NAME2 to collection NAME1. returns a warning if collection is not owned by the user.
    update collection (n)ame <NAME1> <NAME2>
        - updates collection named NAME1 to NAME2. If NAME1 does not exist, or does not belong to user, return a warning.
    rate <NAME> <1|2|3|4|5>
        - rates game with name NAME between 1-5 stars.
    play <NAME> <START_DATE> <END_DATE>
        - logs a play session with start and end date. Total playtime is derived from this.
    follow <(u)sername|(e)mail> <NAME>
        - follows a user by either their email or username.
    follow remove <(u)sername|(e)mail> <NAME>
        - unfollows a user by either email or username.
    """
    
    command = command.split()
    match (command[0]):
        case "help":
            # print help command
            print("""help
                    - lists user commands.
                login <USERNAME>
                    - logs in to account. enables all commands below this line.
                logout
                    - logs out of user account.
                create collection <NAME> (game1, game2, game3...)
                    - creates a collection linked to the user with name NAME and contents gamei.
                get all collections
                    - prints the list of collections associated with the user, ascending order. returns collection name, # of games, and total playtime.
                find game <(n)ame|(p)latform|(r)elease date|(d)eveloper|(pu)blisher|(pl)aytime|(ra)tings> <VALUE> sort by <(n)ame|(p)rice|(g)enre|(r)elease year> <(a)scending|(d)escending>
                    - finds a game by VALUE (specified by type) and sorts by field (asc / desc). Sorted ascending by name then release date by default.
                update collection <(a)dd|(r)emove> <NAME1> <NAME2>
                    - adds / removes game with name NAME2 to collection NAME1. returns a warning if collection is not owned by the user.
                update collection (n)ame <NAME1> <NAME2>
                    - updates collection named NAME1 to NAME2. If NAME1 does not exist, or does not belong to user, return a warning.
                rate <NAME> <1|2|3|4|5>
                    - rates game with name NAME between 1-5 stars.
                play <NAME> <START_DATE> <END_DATE>
                    - logs a play session with start and end date. Total playtime is derived from this.
                follow <(u)sername|(e)mail> <NAME>
                    - follows a user by either their email or username.
                follow remove <(u)sername|(e)mail> <NAME>
                    - unfollows a user by either email or username.
                """)
        case "login":
            print(command[1])
            login(connection, cursor, command[1])
        case "logout":
            logout(connection, cursor)
        case "create":
            match (command[1]):
                case "collection":
                    create_collection(connection, cursor, user, command[2], command[3::])
        case "view":
            match (command[1]):
                case "collection":
                    get_all_collections(connection, cursor, user)
        case "find":
            match (command[1]):
                case "game":
                    find_game(connection, cursor, command[2::])
        case "update":
            match (command[1]):
                case "collection":
                    if (command[2] == "name"):
                        update_collection_name(connection, cursor, command[3], command[4])
                    else:
                        update_collection(connection, cursor, command[2], command[3], command[4])
        case "rate":
            rate(connection, cursor, user, command[1], command[2])
        case "play":
            play(connection, cursor, user, command[1], command[2], command[3])
        case "follow":
            if (command[1] == "remove"):
                unfollow(connection, cursor, command[2], command[3])
            else:
                follow(connection, cursor, command[1], command[2])
        case _:
            print("User may not be logged in. Double check spelling of command or login before running other commands.")
    return


def main(connection, cursor):
    print(  """Welcome to our wonderful database! Login with command login <USERNAME>.\nIf username does not exist, creates a new account.
            """)
    try:
        while True:
            command = input()
            if command.lower() == "quit":
                break
            checkCommandsList(connection, cursor, user, command)
    except Exception as e:
        # fail cleanly
        cursor.close()
        connection.close()
        server.close()
        raise e
    else:
        cursor.close()
        connection.close()
        server.close()
    print("Goodbye!")


def connectToStarbug():
    with open("login.env") as login: # login.env is gitignored, so it's safe (enough) to put credentials in
        starbugUsername = login.readline().split()[-1]
        starbugPassword = login.readline().split()[-1]
    server = SSHTunnelForwarder(('starbug.cs.rit.edu', 22),
                            ssh_username=starbugUsername,
                            ssh_password=starbugPassword,
                            remote_bind_address=('127.0.0.1', 5432))
    server.start()
    print("SSH tunnel established")
    params = {
        'database': "p320_23",
        'user': starbugUsername,
        'password': starbugPassword,
        'host': 'localhost',
        'port': server.local_bind_port
    }

    connection = psycopg2.connect(**params)
    cursor = connection.cursor()
    
    print("Database connection established")
    main(connection, cursor)
    # Use cursor.execute() to perform SQL queries;
    # use connection.commit() to make any changes permanent;
    # use cursor.fetchall() to get the results of a SELECT query;

        
if __name__ == "__main__":
    connectToStarbug()
